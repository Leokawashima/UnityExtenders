using System.Collections.Generic;
using UnityEngine;

public class BeginnerMeshLearning : BeginnerMeshLearningFormatClass
{
    /// <summary>
    /// ”徹底解説！”メッシュ生成クラス　～説明行数驚異の500行～
    /// </summary>
    public void BeginnerCreateMesh()
    {
        #region　”徹底解説！”メッシュ生成へようこそ！

        ///　・簡単　・使いやすい　・初心者でも安心　をモットーに使える、応用できるようにしてるよ！
        ///　玄人のお兄ちゃんお姉ちゃんは回れ右！　しばくぞ！
        ///
        /// 　＜注意＞
        /// 　①説明がめっちゃ多いよ！　少ないよりはマシ！
        /// 　②分かりやすさ重視だから内容を理解している人には理にかなってない部分があったりするよ！
        /// 　　あくまで入門の門をがっぱがぱにオープンする為の説明だからね！　後々なぜなに講座も用意するから気が向いたらやってみてね！
        /// 　③ /// で書かれている僕たちみたいな文は段落ごとに区切ってあるよ！　左側の ?みたいな感じのボックスをクリックすると
        /// 　　折りたたむことができるから適度呼んだところは閉じることをオススメするよ！
        /// 　　また、#region #endregion　で区切られたステップがあるけれど、
        /// 　　これはスクリプトを段落ごとにまとめることができて、表題をつけることができるからコードの整理にとっても便利！
        /// 　　上手く使えれば良いプログラマになれると思うよ！　君も活用してみてね！

        ///　主なステップは３つ！
        ///　①頂点の情報をしまっておく変数を定義！
        ///　②頂点の場所を決めて変数に渡す！
        ///　③変数を使ってメッシュを作る！
        ///　これだけ見たら誰でもできるね！　それじゃあスタート！

        #endregion

        #region ステップ１　～変数をつくろう～

        ///　最初に変数を作るよ！
        ///　作る理由としては、例えば、先生に提出物があったときノートのページを一枚一枚渡す事なんてしないよね？
        ///　ノートにまとめて出せば一発でOK！　まとめる為の変数を作るよ！

        ///　Vector3[]　を用意しよう！
        ///　これは三次元空間だから三軸の座標を表すためだからVector3型！
        ///　名前は頂点の情報をしまうから...vertex(頂点)の複数形の「vertices」にしてみようか！　安直だね！

        Vector3[] vertices;

        ///　この中には頂点の”場所”を入れるよ！
        ///　頂点の数だけ必要になるから　[]　をつけて配列にしているんだね！
        ///　ここでは三次元な座標系の変数を作ったけど、二次元でももちろんOK！　今回は3D世界に描画して、応用させていく前提だから三次元だよ！
        ///　次に頂点をどう結んでポリゴンにするかを決めるための変数を作るよ！

        ///　List<int>　型を用意しよう！
        ///　名前は頂点を結んでポリゴンを作るための変数だから「polygon」とでもしておこうか！　ポケモンじゃないよ！

        List<int> polygon;

        ///　ここで君には二つの疑問があるはずだ！
        ///　①List型ってなに...？
        ///　②なんでさっきは配列を使ったのに配列じゃないの...？
        ///　かいつまんで答えると、
        ///　① List型
        ///　　これはあとから大きさを増やしたり減らしたりできる便利な配列だと思ってね！
        ///　　使い方を間違えるとゲームが重たくなっちゃうけど、使い方を間違えなければ超便利！
        ///　　スクリプトの先頭に System.Collections.Generic; ってあると思うんだけど、それはこの機能を使えるようにする言葉なんだよ！
        ///　②配列を使わない理由　
        ///　　「ポリゴンは頂点情報を三個単位で収める」ことさえ守れば順番はあんまり関係なく最低限使うことができるんだ！
        ///　　三個単位で収め忘れたら大変...と思った君も大丈夫！誰でも簡単がモットーだからね！
        ///　　あらかじめ関数が色々定義されてるからそれを使えば間違えることはないよ！
        ///　　配列は nyan[1].nikukyu みたいな感じで [] の中に数字を入れて指定した要素を設定していく,,,が主だと思うんだ。
        ///　　頂点の場所の情報は一つ一つ場所を決めるから配列にしたんだね。
        ///　　こっちではなぜ配列にしないのかっていうと、上の方で言った通り順番はルールを守ればあんまり関係なくて、
        ///　　結びたい三つの頂点を指定してまとめて入れてあげるだけ。
        ///　　要するに三個まとめて入れていけば、上右下左でも上下右左でもポリゴンを入れる順番はなんでもオッケーってわけだね！
        ///　　分かりやすさ重視で順番とかは極力ムシしていくよ！
        ///　説明が長くなったねごめんね！　もう次のステップ！

        #endregion

        #region ステップ２　～変数に情報を渡そう～

        ///　次に、変数に情報を渡していくよ！
        ///　情報といってもそんな難しくないから大丈夫！　何個頂点を置くのかと、置く場所を決めて、その場所をどう繋ぐか！
        ///　一番最初だから三角形ポリゴンを書くだけにしようか！
        ///　・・・え？そんなのつまらないって？
        ///　じゃあ、三角ポリゴンを４つと四角ポリゴンを1つ組み合わせてちょっとした星を作ろうか！
        ///　まずは、頂点の数を決めるところから！
        ///　
        ///　　　△
        ///　　 ?□?　～想定図～
        ///　　  ▽
        ///　横の三角形が小さいね！　文字入力の限界だ！　上下と同じサイズを想定しているよ！
        ///　頂点の数を数えると...　8個？　16個？　答えは8個！
        ///　頂点はあくまで経由地点！今回は隙間なくポリゴンを貼るから経由地点を使いまわせるから8個で大丈夫ってわけ！
        ///　もしも、
        ///　
        /// 　　　△
        /// 　　　□
        ///  　?□□□?
        ///  　　 □
        ///  　　 ▽
        ///  みたいな感じだったら三角の頂点12個　＋　真ん中の四角の頂点を経由するために16個必要になるね！わかったかな？
        ///  決まったら、頂点の量を設定するよ！
        ///  MeshSupportクラスの　SetVertices関数に頂点量を入れよう！

        vertices = MeshSupport.CreateVertices(16);

        ///　ポリゴンの数はどうだろう？
        ///　ポリゴンは本来三角形の情報しか渡すことができなくて、四角形の場合は三角形を二つ組み合わせて作ることになるんだ！
        ///　MeshSupportクラスでは、考えるのが難しかったり面倒な人のために、
        ///　・ポリゴンを何枚作るか決めないで、後で設定した分だけ数が自動的に決まる引数ナシの状態。
        ///　・三角ポリゴンの個数が分かっている時にその個数を入れることでそれに合わせたサイズになってくれる引数1つの状態。
        ///　・三角ポリゴンの個数も四角ポリゴンも何個あるか分かっていて、それを二つとも入れるとそれに合わせたサイズになってくれる引数2つの状態。
        ///　の三つが引数次第で変化する　CreatePolygon　関数があるよ！
        ///　今回は三角が4つ、四角が1つあるから、引数に2つを入れてみよう！

        polygon = MeshSupport.CreatePolygon(4, 1);

        ///　MeshSupport　は簡単にメッシュを作るための関数が揃ったクラス！
        ///　なにいってるかよくわかんない,,,って子は書いてある通りにそのまま書いて
        ///　数字をいじってどういう動きをするかを観察するのが一番の近道だよ！
        ///　
        ///　このクラスで基本を押さえたら、この関数の中身を理解したり、
        ///　関数を使わずに一通り標準の機能を直接書いてメッシュを描画するのに挑戦する
        ///　「”慣れてきた！”メッシュ生成クラス」があるからやってみてね！
        ///　
        ///　話がそれたね！
        ///　次は、上下左右の三角形の場所を決めていくよ！

        ///　頂点は8個と決めたけど、番号の割り振りはどうしようか？
        ///　オススメは一番上の頂点から外周沿いに時計回りで割り振る事！
        ///　どうしてこれがオススメなのかっていうと...ちょっと長くなるからゆっくり見てね！
        ///
        ///　　　　　　　　　　０
        ///　　　　　　　　　／　＼
        ///　　　　　　　　１ーーー２
        ///　　　　　　　／│　　　│＼
        ///　　　　　　３　│　　　│　４
        ///　　　　　　　＼│　　　│／
        ///　　　　　　　　５ーーー６
        ///　　　　　　　　　＼　／
        ///　　　　　　　　　　７
        ///
        ///　例えば上から右に、下に割り振るとこういう順番になるね。
        ///　このそれぞれの三角形をそれぞれの頂点から試しに結んでみると、
        ///　上の三角形　｛　０－２－１　｝
        ///　右の三角形　｛　４ー６ー２　｝
        ///　下の三角形　｛　７ー５ー６　｝
        ///　左の三角形　｛　３ー１ー５　｝
        ///　となるんだ。　
        ///　三角形を必ず時計回りで結んでいるね？その理由があるんだ。その前に次の説明もさせてね。
        ///
        ///　そして、オススメの方法で結んだ場合も見てみよう。
        ///
        ///　　　　　　　　　　０
        ///　　　　　　　　　／　＼
        ///　　　　　　　　７ーーー１
        ///　　　　　　　／│　　　│＼
        ///　　　　　　６　│　　　│　２
        ///　　　　　　　＼│　　　│／
        ///　　　　　　　　５ーーー３
        ///　　　　　　　　　＼　／
        ///　　　　　　　　　　４
        ///
        ///　この三角形を頂点から結んでみると、
        ///　上の三角形　｛　０－１－７　｝
        ///　右の三角形　｛　２ー３ー１　｝
        ///　下の三角形　｛　４ー５ー３　｝
        ///　左の三角形　｛　６ー７ー５　｝
        ///　となる。
        ///　
        ///　見比べてみると
        ///　　　　左上順　　　　　　　オススメ
        ///　｛　０－２－１　｝   ｛　０－１－７　｝
        ///  ｛　４ー６ー２　｝   ｛　２ー３ー１　｝
        ///  ｛　７ー５ー６　｝   ｛　４ー５ー３　｝
        ///  ｛　３ー１ー５　｝   ｛　６ー７ー５　｝
        ///
        ///　...何が違うか分かるかな？
        ///　左は共通している法則性がパッと見でないように感じるけれど、
        ///　右の方は何か一定の法則で数値が変わっているように見えないかな？
        ///　左と真ん中の列が下に行く毎に [＋２] の法則で数値が増えているんだ！
        ///　でも、右上の７だけが少し例外になっていて、それ以外は [＋２] の法則性を持っているように見えるね。
        ///　この理由は、ポリゴンを結ぶときは、表側が時計回りで結んだ面になるってルールがあるんだ。僕が決めたわけじゃないよ？
        ///　丁度こんな感じ！
        ///　
        ///　　　①                         　          ①
        ///　　　│＼                       　　      ／│
        ///　　　│　＼                     　　　  ／  │
        ///　　　│　　＼           ?      　　　／　　│
        ///　　　│　表　＼                 　　／　裏　│
        ///　　　│　　　　＼               　／　　　　│
        ///　　　③ーーーーー②　　　       ②ーーーーー③
        ///　　　
        ///　見せたい向きから見て時計回りで結ばないといけないルールがあると、
        ///　これから作るような外周が一周してるような図形なら、”時計回り”で順番をつけてあげるほうが、数字に法則性が生まれやすいんだ！
        ///　この法則性が生まれるメリットは何かというと、一つ一つ頂点の場所を設定していくのは、図形が細かくなればなるほど大変だから、
        ///　ループを回して同じ式で場所を決めてあげることができるというのは後々追い風になってくるんだよ！
        ///　法則性を見つけたりするのが得意な子は、法則性の生まれやすい頂点の順番を作るのに向いているかも！　
        ///　炭次郎　お前もメッシュの生成人にならないか？

        ///　そして、オススメの方法で結ぶと右上の「７」だけが例外的に法則性から少し外れていたよね？
        ///　この理由としては、8個の頂点を辺になるように結ぶと分かりやすいかな？
        ///　
        ///　　　　　　　　　　　　　　　　　　０
        ///　①｛　０ー１　｝　　　　　⑧ーー／　＼ーー①
        ///　②｛　１ー２　｝　　　　　　　７　　　１
        ///　③｛　２ー３　｝　　　⑦ーー／　　　　　＼ーー②
        ///　④｛　３ー４　｝　　　　　６　　　　　　　２
        ///　⑤｛　４ー５　｝　　　⑥ーー＼　　　　　／ーー③
        ///　⑥｛　５ー６　｝　　　　　　　５　　　３
        ///　⑦｛　６ー７　｝　　　　　⑤ーー＼　／ーー④
        ///　⑧｛　７ー０　｝　　　　　　　　　４
        ///　
        ///　時計周りに回転すると、角度としては
        ///　０度、45度、90度、135度、180度、225度、270度、315度、360度
        ///　と表記できるよね？
        ///　だけど、このうち　０度　と　360度　は同じ頂点としてカウントできてしまう...
        ///　つまり、360度頂点を一周する図形では、頂点を一周しきる辺を含む面は、例外的に法則性から外れてしまうんだ！
        ///　もっとわかりやすくひし形で図解すると、
        ///　
        ///　　　　　　　　　　　　　　　　　　０
        ///　①｛　０ー１　｝　　　　　④ーー／　＼ーー①
        ///　②｛　１ー２　｝　　　　　　　３　　　１
        ///　③｛　２ー３　｝　　　　　③ーー＼　／ーー②
        ///　④｛　３ー０　｝　　　　　　　　　２
        ///　
        ///　この辺の法則性は、
        ///　for(int i = 0; i < 頂点の数; i++)
        ///　    ｛　i, i + 1　｝
        ///　になるけど、④の辺の組みわせだけこの法則性を満たさないね？
        ///　この辺だけは頂点を一周しきる辺だから、
        ///　｛　270度ー360度　｝の組み合わせになって、360度は０度と座標を共有しているから、本来360度の頂点がもう一つあって、
        ///　
        ///　　　　　　　　　　　　　　　　　　０(４)
        ///　①｛　０ー１　｝　　　　　④ーー／　＼ーー①
        ///　②｛　１ー２　｝　　　　　　　３　　　１
        ///　③｛　２ー３　｝　　　　　③ーー＼　／ーー②
        ///　④｛　３ー４　｝　　　　　　　　　２
        ///
        ///　このようにもう一つ頂点を用意すれば、ここまでの例外的な法則性は生まれないし、他にもメリットが生まれることがあるよ！用法容量！
        ///　でも、今回のような一周する図形においては、全く同じ情報を持っている頂点を用意することは無駄な気がするね...
        ///　例外が生まれる原因と、それを対策した法則性にのっとった定義するループ式を書くことを理解できていれば、
        ///　このような場合は無駄な頂点を増やす必要がなくなって、メモリを無駄に使用することがなくなるね！
        ///　
        ///　座標が重なった頂点を使ってポリゴンを書くと、デメリットが生まれる場合があることも紹介しておくよ！
        ///　いずれ複数の座標を入れるとそこを中心に四角形を描画する、みたいなことをするときに、
        ///
        ///　１ーーー２　　５ーーー６
        ///　│　　　│　　│　　　│
        ///　│　①　│　　│　②　│
        ///　│　　　│　　│　　　│
        ///　３ーーー４　　７ーーー８
        ///
        ///　こんな感じで頂点を用意する時は、
        ///　
        ///　　　　５ーーー６
        ///　１ーー✛２　　│
        ///　│　　││②　│
        ///　│　①││　　│
        ///　│　　７✛ーー８
        ///　３ーーー４
        ///
        ///　こんな風に面が重なるときに奥行も全く同じだと
        ///　見る角度によってポリゴンが交互に見え隠れするチラつきの現象が起きてしまうんだ。
        ///　もし、こんな風に重なってしまう場合は、
        ///　
        ///　　　　　　　　５６　　　　９ーー10
        ///　１ーー２　　　││　　　　│　　│
        ///　│　　│　＋　││　　＋　│ ② │
        ///　│ ① │　　　││　　　　│　　│
        ///　│　　│　　　││　　　　11ーー12
        ///　３ーー４　　　７８
        ///　　　　　　　　　　↖かぶさっている範囲を分割した新メッシュ
        /// 
        ///　このように面を分割してあげる仕組みを実装する方法を実装するだとか、
        ///　近い頂点を自動的に合成するような機能を作ったりする方法など様々あるよ！これも用法容量！
        ///　本来三次元の座標軸でメッシュを使うならそこまでメッシュのかぶさりが生まれることは少ないと思うけど、
        ///　四角形な物体ではこの問題が特に起こりやすいよ！　そこまで意識して作れるようになったら一人前！

        ///　また話が長くなったね！とりあえず時計回りに座標を振るよ！
        ///　上の頂点が Y = 3　で右の頂点が X = 3　になるようにおいていくよ！

        vertices[0] = new Vector3(0, 3, 0);//上の頂点だヨ
        vertices[1] = new Vector3(1, 1, 0);
        vertices[2] = new Vector3(3, 0, 0);//右の頂点だヨ
        vertices[3] = new Vector3(1, -1, 0);
        vertices[4] = new Vector3(0, -3, 0);//下の頂点だヨ
        vertices[5] = new Vector3(-1, -1, 0);
        vertices[6] = new Vector3(-3, 0, 0);//左の頂点だヨ
        vertices[7] = new Vector3(-1, 1, 0);

        ///　これで頂点の配置はOK！
        ///　これを数式で設定できるともっと頂点が増えても簡単だよ！
        ///　試しにこの頂点の配置をすべて満たす式を書いてみるとこんな感じ！

        /*
        for(int i = 0; i < _vertices.Length; i++)
        {
            float i_angle = (360 / (float)i) * Mathf.Deg2Rad;
            float i_range = i % 2 ? 1 : 3;
            _vertices[i] = new Vector3(Mathf.Sin(i_angle) * i_range, Mathf.Cos(i_angle) * i_range, 0);
        }
        */

        ///　うん！　パッと見よくわかんないね！　
        ///　一応解説すると、頂点が偶数個なら頂点数が増えれば増えるほどウニみたいな配置を行うよ！
        ///　i_angleでの３を大きくすればすごい鋭利なウニになるから後で試してね！
        ///　1人でメッシュ生成をマスターできたらいろんな幾何学模様を作ってみたいね！　頑張ろう！

        ///　次にさっき説明した通り時計回りにポリゴンを設定するよ！
        ///　ポリゴンの設定はMeshSupportクラスで用意した関数二つが便利！
        ///　引数に頂点番号を時計回り順に3つ入れて三角形を設定する　SetTriangle()　関数！
        ///　引数に左下、左上、右下、右上の頂点番号を4つ入れて四角形を設定　SetQuad()　関数！
        ///　引数の順番に気を付けてね！

        polygon.SetTriangle(0, 1, 7);
        polygon.SetTriangle(2, 3, 1);
        polygon.SetTriangle(4, 5, 3);
        polygon.SetTriangle(6, 7, 5);

        ///　あとは四角形だね！
        ///　左下とあるけど、映したい方向から見て、一つの点を始点に決めたら、
        ///　そこから相対的な左下、左上...みたいに頂点を入れるだけで大丈夫だよ！
        ///　それじゃあ設定してみよう！

        polygon.SetQuad(5, 7, 3, 1);

        ///　これで変数の設定は完了！
        ///　まとめると、
        ///　①頂点の量を決める。
        ///　②ポリゴンの量を決める。
        ///　③頂点の場所を決める。
        ///　④ポリゴンの貼り方を決める。
        ///　たったこれだけ！　細かく意識すべきポイントをたくさん解説したから長くなっちゃったけどたったこれだけなんだね！
        ///　情報を取り決めたらあとはメッシュを作るだけ！
        ///　最後のステップへ行ってみよう！

        #endregion

        #region　ステップ３　～変数からメッシュを作ろう～

        ///　最後はメッシュを作るよ！
        ///　といっても、難しくないから安心してね！
        ///　まずは　Mesh型　の変数を作ろう！

        Mesh mesh;

        ///　この変数にさっき用意した変数を使って作ったメッシュを設定するよ！
        ///　本当なら色々細かく設定する項目があるんだけれど、安心して！
        ///　MeshSupportクラスの　CreateMesh関数で設定した頂点とポリゴンの貼り方を渡してあげるだけ！

        mesh = MeshSupport.CreateMesh(vertices, polygon);

        ///　設定できたかな？
        ///　これでメッシュは完成！
        ///　え？　最後が一番簡単だって？　基本的に情報を渡すだけだから、
        ///　頂点の場所と貼り方(結び方)を設定すれば、あとは流れ作業で大丈夫なんだね！
        ///　あとは出来上がったメッシュを使って描画しよう！
        ///　...といっても、このままこのスクリプトをアタッチしてもメッシュを描画できないんだ。
        ///　なぜかというと、
        ///　①この関数を呼び出さないとメッシュが生成されない。
        ///　②メッシュがあっても、描画する処理が書かれていない。
        ///　この二点が挙げられるね。
        ///　
        ///　①の問題は、void Start()　や　void Update()　等々Unityが用意してくれている関数の中に書くなどもできるね！
        ///　でも、毎回ゲームを再生しないと結果が確認できないのは非効率的！
        ///　なので、ちょっと難しい話だから興味がある人だけ〇付きの数字の項目を読んでみてね。
        ///　①コンパイルされる時に呼び出してくれるようにする。UnityEditor.callbacks の [DidReloadScript] 属性をつける。←興味がある人は検索！
        ///　②OnReset() や OnValidate() に記述してプロパティを開いてResetををかける、
        ///　　[SerializeField] bool Script_Update = false;等で更新できるようにする。　←Onvalidate()　これ変数をいじると中に記述したのが呼ばれるから調べてみて！！！
        ///　
        ///　読んでくれた人も聞き流してくれた人もここで合流！
        ///　上で書いた若干遠回りなゲームを再生せずに関数を呼ぶ方法があったりしたんだけれど、やっぱり遠回り。
        ///　だから、このコンポーネント上にボタンを配置してこの関数を呼び出せるようにしてあるよ！
        ///　「 Unity　インスペクター　ボタン 」とかで検索するとインスペクター上に関数を呼ぶボタンを作る方法が乗ってたりしてるから、
        ///　ちょっとコピペして遊んでみると面白いかも！
        ///　とりあえず、ボタンから関数を呼べるから①の問題はクリアだね！
        ///　
        ///　でも、②の描画する処理が書かれていないね？
        ///　ここではメッシュを描画するためのアプローチとして、
        ///　MeshFilterコンポーネント
        ///　MeshRendererコンポーネント
        ///　という二つのコンポーネントを同時に使うことでメッシュを描画する方法を使うよ！
        ///　この　BeginnerMeshコンポーネントをオブジェクトに割り当てるだけで、
        ///　オブジェクトにその二つのコンポーネントが追加されるからわざわざコンポーネントを追加する必要はないよ！
        ///　あとは、MeshFilterコンポーネントに今作ったメッシュを割り当てるだけでコンポーネント達が描画してくれるから、
        ///　用意してある　SetMeshOnMeshFilter()関数に引数としてメッシュを入れて割り当ててみよう！
        ///　
        ///　SetMeshOnMeshFilter(mesh);
        ///　
        ///　を追加してみよう！　下の空きスペースに書いてみてね！



        ///　さあ、書き終わったかな？
        ///　この時点で、メッシュを作って割り当てるまでが終わったから、
        ///　このコンポーネントをゲームオブジェクトに割り当ててみて、
        ///　BeginnerMeshコンポーネントの”生成関数呼び出しボタン”を押してみよう！

        ///　あれ？　色が変だね？
        ///　メッシュを生成して、色も自分で決めたい時はマテリアルを
        ///　　Meshrendererコンポーネント　に設定する必要があるよ！
        ///　質感を細かく設定したい時は自分で作るべきだけれど、分かんない！　めんどくさい！
        ///　って子は　SetColorOnMeshRenderer()　関数を用意しているよ！　引数にColor型を入れてあげるだけ！
        ///　Color型ってなんだよー！って子はこの後使い方を解説するよ！ちょっと待ってね！
        ///　
        ///　SetColorOnMeshRenderer(Color.red);
        ///　
        ///　を追加してみよう！



        ///　Color型の解説だよ！
        ///　Color型とは、「 RGBA 」の情報を持った色に特化した変数なんだ！
        ///　R　＝　"R"ed　　 赤色 を 0 ～ 255 の間の値で設定するよ！
        ///　G　＝　"G"reen　 緑色 を 0 ～ 255 の間の値で設定するよ！
        ///　B　＝　"B"lue　  青色 を 0 ～ 255 の間の値で設定するよ！
        ///　A　＝　"A"lpha　透明度を 0 ～ 255 の間の値で設定するよ！
        ///　このようにそれぞれの頭文字をとっっているから「 RGBA 」と呼ぶんだね！
        ///　それぞれで 0 ～ 255 の情報を持っているから256色の3乗で、
        ///　「 16,777,216 色」つまり約1680万通りの色を表せるよ！　白が200色あっても当然だね！
        ///　これだけの色に合わせて透明度をもつアルファの値があって、例えばアルファに127の値を入れると言葉通り「半透明」になるよ！
        ///　もしアルファ値も合わせた色の組み合わせは256色の4乗で、
        ///　「 4,294,967,296 色」つまり約43億通りの色になるよ！　白って何色あんねん？
        ///　話を戻して...
        ///　Unityでは Color型 の変数を定義するには大きく3つのアプローチがあるよ！
        ///　
        ///　①Color　変数名　＝　new　Color( R, G, B, A )の引数に0.0f～1.0fのを入れる「引数」指定！
        ///　　値を細かく指定できて、0.5f等で半分を簡単に設定できる！　色を作るならだいたいこれ！
        ///　　
        ///　②ColorUtility.TryParseHtmlString(文字コード, out 変数名)の引数に文字コードを入れる「カラーコード」指定！
        ///　　#00FF07FF　みたいな感じの文字を見たことあるかな？　これはネットのページとかで色を指定するときによく使われるんだ！
        ///　　
        ///　③Color　変数名　＝　Color."色の種類" でUnity側で既に用意された色を指定する「名前」指定！
        ///　　名前を書くだけで一発！　楽チン！　自分で名前を追加して定義もできるよ！
        ///　
        ///　形式的には色を自分で決める引数指定か名前で指定することになるね！
        ///　この名前は色の英語なんだけれど、簡単に名前のリストを書いておくね！
        ///　
        ///　Color.red　　　赤
        ///　Color.green　　緑
        ///　Color.blue　　 青
        ///　Color.yellow　 黄
        ///　Color.white　　白
        ///　Color.black　　黒
        ///　
        ///　そこまで色の種類は多くないけれど、色をサクッと変えるには十分だね！
        ///　この色をさっきも紹介した
        ///　
        ///　SetColorOnMeshRenderer(好きな色);
        ///　
        ///　の好きな色の所に入れてみてね！
        ///　ちなみに、少しこのクラスでは色を少し足してあるから気になる人は試してみてね！
        ///　書き方が少し異なって、
        ///　
        ///　pink　　　　桃
        ///　orange　　　橙
        ///　purple　　　紫
        ///　
        ///　とそのまま名前を入れるだけでOKだよ！
        ///　色の使い方が分かったらレッツセット！

        #endregion

        #region　おさらい！

        ///　ステップ１では変数を作ったね！
        ///　今回は　｛　型　変数名;　｝　でまず型を宣言してからステップ２に入って配列の大きさなどを決めていたけど、
        ///　1行にまとめたほうが本来はコードがすっきりするし、その変数の大きさが分かりやすいから、
        ///　Vector3[] vertices = SetVertices(???)　等で大きさを決めてあげるとレベルアップ！

        ///　ステップ２では変数に情報を渡していったね！
        ///　頂点の場所は数式で書いた場合を既に書いてあったけれど、ここではポリゴンを貼るループを例として書いてみるよ！
        ///　
        ///　for(int i = 0; i < 三角形の数-1; i++)
        ///　{
        ///　    int mul2 = i * 2;
        ///　    _polygon.SetTriangle(mul2 + 2, mul2 + 3, mul2 + 1);
        ///　}
        ///　_polygon.SetTriangle(0, 1, 7);
        ///
        ///　なぜループから一つ外して回いるのかというと、
        ///　説明した通り360度頂点が一周する図形での、一周しきる辺を含む面は例外的に数字が法則性を抜けてしまうので、
        ///　360度頂点が一周する図形ではあえて外している、というのが答えになるね！
        ///　また、今回はループを分かりやすくするために 0→2 まで i が増えるループにしたけれど、
        ///　計算量をループ毎に減らすことを意識しないとループが大きくなった時処理が重たくなっちゃうから、
        ///　
        ///  int loop = 三角形の数 - 1;
        ///　for (int i = 1; i <= loop; i++)
        ///　{
        ///　    int mul2 = i * 2;
        ///　    _polygon.SetTriangle(mul2 + 1, Mul2 + 2, Mul2);
        ///　}
        ///　_polygon.SetTriangle(0, 1, 7);
        ///　
        ///　こんな風にループする数字を一つ後ろにずらす事でカッコ内の3個目の計算式を一つそのまま変数に置き換えることができているから、
        ///　少しだけ効率的になったね！　ループの判定式も毎ループごとに呼ばれてしまうから、
        ///　i = 1, loop = 三角形の数 - 1;と定義した方が変数のスコープがループ内に収まって本当はそっちのほうが良いんだけれど、読みづらいからあえて外したよ！
        ///　ループに関する宣言と計算処理は詳しいことはググるか先生に聴くことをお勧めするよ！
        ///　「変数をループの外で作るか内で作るか」　というキーワードでQ&Aに答えているネットのページがあって、そこでコンパイル次第だとかいろんな説明がされているから気になった人は調べてね！
        ///　頂点数をもっと増やして細かい図形を作るときは必ず計算量を意識してループと計算式を決めるべきだよ！

        ///　ステップ３ではメッシュを作ったね！
        ///　メッシュを作るときも変数を作るときと同じで
        ///　Mesh mesh = MeshSupport.CreateMesh();　でまとめて書く方が行をまたいで書くよりも中に何が入っているかが明確になるからオススメだよ！
        ///　また、今回は　MeshFilterコンポーネント等を用いたアプローチで描画してみたけれど、
        ///　このコンポーネントたちが勝手に追加されてくれたり、関数に引数を入れて1行呼び出すだけでメッシュが描画されるようになったのは、
        ///　わざわざ追加する手間を省いたり、メッシュを作成する手順を理解するにあたって少し難解な手順が必要になるからあらかじめ用意しておいたんだ。
        ///　他のクラスでSetMeshOnMeshFilter関数を呼び出そうとすると通常はできないから、気を付けてね。
        ///　できる子は元のクラスを使いまわしたり必要なものだけ抜いて使ってみよう！
        /// 
        ///　ゲームを作ったり機能を作るにあたって知っておいた方がイイこと。
        ///　あまり人が教えてくれないこと、調べ方が難しいもの。
        ///
        ///　分かる範囲で参考になるページのURLを貼ったり、それについての解説も他のスクリプトで行う予定だよ！
        ///　今回は　”徹底解説！”メッシュ生成クラス　ということで解説をかなり多くしていったけど、
        ///　色々な便利関数を揃えたクラスや他にもこのような解説を行っているクラスを用意しているので、
        ///　初めてUnityを触ったけどよくわかんない...調べるのも良いけど折角聞けるんだから先生とか人に聞いてみたい...という
        ///　悩みの解決の種に少しでもなれたら嬉しいな！
        ///　今回の解説はここで終わるよ！　良いUnityライフを！

        #endregion
    }
}
